---
import CodexLayout from "../layouts/CodexLayout.astro";
import { CodexEngine } from "../codex/engine";

const initialEntries = CodexEngine.list();
const codexEndpoint = import.meta.env.PUBLIC_CODEX_ENDPOINT ?? "/api/codex";
---

<CodexLayout title="Live Codex" description="Streaming artifact ledger sourced from Codex Worker.">
  <section class="flex flex-col gap-8">
    <header class="text-center">
      <p class="text-xs uppercase tracking-[0.45em] text-white/60">Live Telemetry</p>
      <h1 class="gradient-text text-4xl font-semibold">Codex Feed</h1>
      <p class="mx-auto mt-3 max-w-2xl text-white/70">
        Entries below update whenever the worker emits a new packet. Keep this view open to monitor Omni writes and Genesis pings in real time.
      </p>
      <div class="mx-auto mt-6 grid w-full max-w-3xl gap-4 rounded-2xl border border-white/15 bg-black/30 p-4 text-left sm:grid-cols-3">
        <div>
          <p class="text-xs uppercase tracking-[0.35em] text-white/50">Artifacts</p>
          <p class="text-2xl font-semibold" id="codexCount">{initialEntries.length}</p>
        </div>
        <div>
          <p class="text-xs uppercase tracking-[0.35em] text-white/50">Last Sync</p>
          <p class="text-2xl font-semibold" id="codexSync">{new Date().toLocaleTimeString()}</p>
        </div>
        <div>
          <p class="text-xs uppercase tracking-[0.35em] text-white/50">Endpoint</p>
          <p class="text-sm text-white/70 break-all">{codexEndpoint}</p>
        </div>
      </div>
    </header>

    <div class="grid gap-4" id="codexStream">
      {initialEntries.map((entry) => (
        <article class="glass-panel border-glow flex flex-col gap-4 p-5" data-entry-id={entry.id}>
          <header class="flex items-center justify-between gap-4">
            <div>
              <p class="text-xs uppercase tracking-[0.4em] text-white/60">{entry.sector}</p>
              <h2 class="text-2xl font-semibold">{entry.title}</h2>
            </div>
            <span class="rounded-full border border-white/20 px-3 py-1 text-xs uppercase tracking-[0.2em] text-white/70">
              {entry.priority}
            </span>
          </header>
          <p class="text-white/70">{entry.synopsis}</p>
          <div class="flex flex-wrap gap-2 text-xs text-white/70">
            {entry.tags.map((tag) => (
              <span class="rounded-full border border-white/20 px-3 py-1">{tag.label}</span>
            ))}
          </div>
          <footer class="text-xs uppercase tracking-[0.3em] text-white/50">
            Updated {new Date(entry.updatedAt).toLocaleString()}
          </footer>
        </article>
      ))}
    </div>

    <template id="codex-entry-template">
      <article class="glass-panel border-glow flex flex-col gap-4 p-5">
        <header class="flex items-center justify-between gap-4">
          <div>
            <p class="text-xs uppercase tracking-[0.4em] text-white/60"></p>
            <h2 class="text-2xl font-semibold"></h2>
          </div>
          <span class="rounded-full border border-white/20 px-3 py-1 text-xs uppercase tracking-[0.2em] text-white/70"></span>
        </header>
        <p class="text-white/70"></p>
        <div class="flex flex-wrap gap-2 text-xs text-white/70"></div>
        <footer class="text-xs uppercase tracking-[0.3em] text-white/50"></footer>
      </article>
    </template>

    <script type="application/json" id="codex-initial-data">{JSON.stringify(initialEntries)}</script>

    <script>
      const endpoint = import.meta.env.PUBLIC_CODEX_ENDPOINT ?? '/api/codex';
      const host = endpoint.replace(/\/$/, '');
      const listUrl = `${host}/entries`;
      const streamUrl = `${host}/stream`;

      async function refreshList() {
        try {
          const res = await fetch(listUrl);
          if (!res.ok) return;
          const payload = await res.json();
          renderEntries(payload.entries ?? []);
          updateStats(payload.entries ?? []);
        } catch (err) {
          console.error('Codex refresh failed', err);
        }
      }

      function renderEntries(entries) {
        const container = document.getElementById('codexStream');
        const template = document.getElementById('codex-entry-template');
        if (!container || !template) return;
        container.innerHTML = '';

        entries.forEach((entry) => {
          const clone = template.content.firstElementChild.cloneNode(true);
          const [sectorEl, titleEl] = clone.querySelectorAll('header div > *');
          const priorityEl = clone.querySelector('header span');
          const synopsisEl = clone.querySelector('p.text-white/70');
          const tagsEl = clone.querySelector('div.flex');
          const footerEl = clone.querySelector('footer');

          sectorEl.textContent = entry.sector;
          titleEl.textContent = entry.title;
          priorityEl.textContent = entry.priority;
          synopsisEl.textContent = entry.synopsis;
          tagsEl.innerHTML = '';
          (entry.tags ?? []).forEach((tag) => {
            const span = document.createElement('span');
            span.className = 'rounded-full border border-white/20 px-3 py-1';
            span.textContent = tag.label;
            tagsEl.appendChild(span);
          });
          footerEl.textContent = `Updated ${new Date(entry.updatedAt).toLocaleString()}`;

          clone.dataset.entryId = entry.id;
          container.appendChild(clone);
        });
      }

      function updateStats(entries) {
        const countEl = document.getElementById('codexCount');
        const syncEl = document.getElementById('codexSync');
        if (countEl) countEl.textContent = entries.length.toString().padStart(2, '0');
        if (syncEl) syncEl.textContent = new Date().toLocaleTimeString();
      }

      function startStream() {
        try {
          const source = new EventSource(streamUrl);
          source.addEventListener('codex', (event) => {
            const payload = JSON.parse(event.data);
            renderEntries(payload.entries ?? []);
            updateStats(payload.entries ?? []);
          });
          source.onerror = () => {
            source.close();
            setTimeout(startStream, 5000);
          };
        } catch (err) {
          console.error('Codex stream failed', err);
        }
      }

      renderEntries(JSON.parse(document.getElementById('codex-initial-data').textContent || '[]'));
      startStream();
      setInterval(refreshList, 30000);
    </script>
  </section>
</CodexLayout>
